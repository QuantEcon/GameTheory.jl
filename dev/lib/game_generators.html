<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Game Generators · GameTheory.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">GameTheory.jl</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="base_types_and_methods.html">Base Types and Methods</a></li><li class="is-active"><a class="tocitem" href="game_generators.html">Game Generators</a><ul class="internal"><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li><li><a class="tocitem" href="computing_nash_equilibria.html">Computing Nash Equilibria</a></li><li><a class="tocitem" href="learning_algorithms.html">Learning Algorithms</a></li><li><a class="tocitem" href="repeated_games.html">Repeated Games</a></li><li><a class="tocitem" href="util.html">Utilities</a></li><li><a class="tocitem" href="index.html">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="game_generators.html">Game Generators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="game_generators.html">Game Generators</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantEcon/GameTheory.jl/blob/main/docs/src/lib/game_generators.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="game_generators"><a class="docs-heading-anchor" href="#game_generators">Game Generators</a><a id="game_generators-1"></a><a class="docs-heading-anchor-permalink" href="#game_generators" title="Permalink"></a></h1><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="GameTheory.covariance_game-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}, Real}} where N" href="#GameTheory.covariance_game-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}, Real}} where N"><code>GameTheory.covariance_game</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">covariance_game([rng=GLOBAL_RNG], nums_actions, rho)</code></pre><p>Return a random N-player NormalFormGame instance with N&gt;=2 where the payoff profiles are drawn independently from the standard multi-normal with the covariance of any pair of payoffs equal to <code>rho</code>, as studied in Rinott and Scarsini (2000).</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>nums_actions::NTuple{N,Int}</code>: Tuple of the numbers of actions, one for each player.</li><li><code>rho::Real</code>: Covariance of a pair of payoff values. Must be in [-1/(N-1), 1], where N is the number of players.</li></ul><p><strong>Returns</strong></p><ul><li><code>::NormalFormGame</code>: The generated random N-player NormalFormGame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory, Random

julia&gt; rng = MersenneTwister(12345);

julia&gt; g = covariance_game(rng, (4, 3), -0.7);

julia&gt; println(g)
4×3 NormalFormGame{2, Float64}:
 [1.17236, -0.211696]   [1.46647, -1.13947]    [0.378353, 0.603951]
 [0.415565, 0.0779055]  [0.606808, 1.00812]    [1.12871, -1.03399]
 [0.685759, -0.278449]  [-0.588508, 0.464548]  [-0.970332, -0.0319236]
 [-1.47708, 1.12447]    [1.92585, -2.27959]    [-2.1476, 1.53569]</code></pre><p><strong>References</strong></p><ul><li>Y. Rinott and M. Scarsini, &quot;On the Number of Pure Strategy Nash Equilibria in Random Games,&quot; Games and Economic Behavior (2000), 274-293.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/random.jl#L81-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.random_game-Union{Tuple{T}, Tuple{N}, Tuple{Random.AbstractRNG, Union{AbstractRange{T}, Type{T}}, Tuple{Vararg{Int64, N}}}} where {N, T&lt;:Real}" href="#GameTheory.random_game-Union{Tuple{T}, Tuple{N}, Tuple{Random.AbstractRNG, Union{AbstractRange{T}, Type{T}}, Tuple{Vararg{Int64, N}}}} where {N, T&lt;:Real}"><code>GameTheory.random_game</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_game([rng=GLOBAL_RNG], [S=Float64], nums_actions)</code></pre><p>Return a random N-player NormalFormGame instance where the payoffs are drawn independently from the uniform distribution on the set as determined by <code>S</code>. <code>S</code> is a range (such as <code>0:9</code>) or a subtype of <code>Integer</code> or <code>AbstractFloat</code>; in the latter case, the set is [0, 1) for floats and <code>typemin(S):typemax(S)</code> for integers.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>S::Union{Type,AbstractRange}</code>: Set of values from which payoffs are drawn.</li><li><code>nums_actions::NTuple{N,Int}</code>: Tuple of the numbers of actions, one for each player.</li></ul><p><strong>Returns</strong></p><ul><li><code>::NormalFormGame</code>: The generated random N-player NormalFormGame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory, Random

julia&gt; rng = MersenneTwister(12345);

julia&gt; g = random_game(rng, (4, 3));

julia&gt; println(g)
4×3 NormalFormGame{2, Float64}:
 [0.562714, 0.586598]  [0.381128, 0.0501668]  [0.922317, 0.61179]
 [0.849939, 0.620099]  [0.365801, 0.215712]   [0.0404417, 0.569955]
 [0.371605, 0.965631]  [0.835014, 0.364706]   [0.573382, 0.923602]
 [0.283365, 0.754047]  [0.260024, 0.696476]   [0.981364, 0.0311643]

julia&gt; g = random_game(rng, 0:9, (4, 3));

julia&gt; println(g)
4×3 NormalFormGame{2, Int64}:
 [1, 5]  [1, 2]  [6, 2]
 [2, 5]  [0, 2]  [1, 0]
 [0, 5]  [3, 9]  [1, 1]
 [9, 5]  [2, 9]  [0, 6]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/random.jl#L8-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.random_mixed_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N" href="#GameTheory.random_mixed_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N"><code>GameTheory.random_mixed_actions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_mixed_actions([rng=GLOBAL_RNG], nums_actions)</code></pre><p>Return a tuple of random mixed actions (vectors of floats).</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>nums_actions::NTuple{N,Int}</code>: N-tuple of the numbers of actions, one for each player.</li></ul><p><strong>Returns</strong></p><ul><li><code>::NTuple{N,Vector{Float64}}</code>: N-tuple of random mixed actions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/random.jl#L178-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.random_pure_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N" href="#GameTheory.random_pure_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N"><code>GameTheory.random_pure_actions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">random_pure_actions([rng=GLOBAL_RNG], nums_actions)</code></pre><p>Return a tuple of random pure actions (integers).</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>nums_actions::NTuple{N,Int}</code>: N-tuple of the numbers of actions, one for each player.</li></ul><p><strong>Returns</strong></p><ul><li><code>::NTuple{N,Int}</code>: N-tuple of random pure actions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/random.jl#L156-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.Generators.blotto_game" href="#GameTheory.Generators.blotto_game"><code>GameTheory.Generators.blotto_game</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">blotto_game([rng=GLOBAL_RNG], h, t, rho[, mu=0])</code></pre><p>Return a NormalFormGame instance of a 2-player non-zero sum Colonel Blotto game (Hortala-Vallve and Llorente-Saguer, 2012), where the players have an equal number <code>t</code> of troops to assign to <code>h</code> hills (so that the number of actions for each player is equal to (t+h-1) choose (h-1) = (T+h-1)!/(T!*(h-1)!)). Each player has a value for each hill that he receives if he assigns strictly more troops to the hill than his opponent (ties are broken uniformly at random), where the values are drawn from a multivariate normal distribution with covariance <code>rho</code>. Each player’s payoff is the sum of the values of the hills won by that player.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>h::Integer</code> : Number of hills.</li><li><code>t::Integer</code> : Number of troops.</li><li><code>rho::Real</code> : Covariance of the players&#39; values of each hill. Must be in [-1, 1].</li><li><code>mu::Real=0</code> : Mean of the players&#39; values of each hill.</li></ul><p><strong>Returns</strong></p><ul><li><code>g::NormalFormGame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory.Generators, Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; g = blotto_game(rng, 2, 3, 0.5)
4×4 NormalFormGame{2, Float64}

julia&gt; g.players[1]
4×4 Player{2, Float64}:
 0.186434  -0.494479  -0.494479  -0.494479
 0.867347   0.186434  -0.494479  -0.494479
 0.867347   0.867347   0.186434  -0.494479
 0.867347   0.867347   0.867347   0.186434

julia&gt; g.players[2]
4×4 Player{2, Float64}:
 -0.688223  -1.02919   -1.02919   -1.02919
 -0.347259  -0.688223  -1.02919   -1.02919
 -0.347259  -0.347259  -0.688223  -1.02919
 -0.347259  -0.347259  -0.347259  -0.688223</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/generators/bimatrix_generators.jl#L93-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.Generators.ranking_game" href="#GameTheory.Generators.ranking_game"><code>GameTheory.Generators.ranking_game</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ranking_game([rng=GLOBAL_RNG], n[, steps=10])</code></pre><p>Return a NormalFormGame instance of (the 2-player version of) the &quot;ranking game&quot; studied by Goldberg et al. (2013), where each player chooses an effort level associated with a score and a cost which are both increasing functions with randomly generated step sizes. The player with the higher score wins the first prize, whose value is 1, and the other player obtains the &quot;second prize&quot; of value 0; in the case of a tie, the first prize is split and each player receives a value of 0.5. The payoff of a player is given by the value of the prize minus the cost of the effort.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>n::Integer</code> : Number of actions, i.e, number of possible effort levels.</li><li><code>steps::Integer=10</code> : Parameter determining the upper bound for the size of the random steps for the scores and costs for each player: The step sizes for the scores are drawn from <code>1</code>, ..., <code>steps</code>, while those for the costs are multiples of <code>1/(n*steps)</code>, where the cost of effort level <code>1</code> is 0, and the maximum possible cost of effort level <code>n</code> is less than or equal to 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>g::NormalFormGame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory.Generators, Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; g = ranking_game(rng, 5)
5×5 NormalFormGame{2, Float64}

julia&gt; g.players[1]
5×5 Player{2, Float64}:
 0.5    0.0    0.0    0.0    0.0
 0.92  -0.08  -0.08  -0.08  -0.08
 0.88   0.88   0.88   0.88  -0.12
 0.74   0.74   0.74   0.74   0.74
 0.58   0.58   0.58   0.58   0.58

julia&gt; g.players[2]
5×5 Player{2, Float64}:
 0.5   0.0    0.0    0.0    0.0
 0.92  0.92  -0.08  -0.08  -0.08
 0.76  0.76  -0.24  -0.24  -0.24
 0.56  0.56  -0.44  -0.44  -0.44
 0.44  0.44   0.44  -0.56  -0.56</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/generators/bimatrix_generators.jl#L184-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.Generators.sgc_game-Tuple{Integer}" href="#GameTheory.Generators.sgc_game-Tuple{Integer}"><code>GameTheory.Generators.sgc_game</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sgc_game(k)</code></pre><p>Return a NormalFormGame instance of the 2-player game introduced by Sandholm, Gilpin, and Conitzer (2005), which has a unique Nash equilibrium, where each player plays half of the actions with positive probabilities. Payoffs are normalized so that the minimum and the maximum payoffs are 0 and 1, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>k::Integer</code> : Positive integer determining the number of actions. The returned game will have <code>4*k-1</code> actions for each player.</li></ul><p><strong>Returns</strong></p><ul><li><code>g::NormalFormGame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory.Generators

julia&gt; g = sgc_game(2)
7×7 NormalFormGame{2, Float64}

julia&gt; g.players[1]
7×7 Player{2, Float64}:
 0.75  0.5   1.0   0.5   0.5   0.5   0.5
 1.0   0.75  0.5   0.5   0.5   0.5   0.5
 0.5   1.0   0.75  0.5   0.5   0.5   0.5
 0.0   0.0   0.0   0.75  0.0   0.0   0.0
 0.0   0.0   0.0   0.0   0.75  0.0   0.0
 0.0   0.0   0.0   0.0   0.0   0.75  0.0
 0.0   0.0   0.0   0.0   0.0   0.0   0.75

julia&gt; g.players[2]
7×7 Player{2, Float64}:
 0.75  0.5   1.0   0.5   0.5   0.5   0.5
 1.0   0.75  0.5   0.5   0.5   0.5   0.5
 0.5   1.0   0.75  0.5   0.5   0.5   0.5
 0.0   0.0   0.0   0.0   0.75  0.0   0.0
 0.0   0.0   0.0   0.75  0.0   0.0   0.0
 0.0   0.0   0.0   0.0   0.0   0.0   0.75
 0.0   0.0   0.0   0.0   0.0   0.75  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/generators/bimatrix_generators.jl#L277-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.Generators.tournament_game-Tuple{Random.AbstractRNG, Integer, Integer}" href="#GameTheory.Generators.tournament_game-Tuple{Random.AbstractRNG, Integer, Integer}"><code>GameTheory.Generators.tournament_game</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tournament_game([rng=GLOBAL_RNG], n, k)</code></pre><p>Return a NormalFormGame instance of the 2-player win-lose game, whose payoffs are either 0 or 1, introduced by Anbalagan et al. (2013). Player 1 has n actions, which constitute the set of nodes {1, ..., n}, while player 2 has n choose k actions, each corresponding to a subset of k elements of the set of n nodes. Given a randomly generated tournament graph on the n nodes, the payoff for player 1 is 1 if, in the tournament, the node chosen by player 1 dominates all the nodes in the k-subset chosen by player 2. The payoff for player 2 is 1 if player 2&#39;s k-subset contains player 1&#39;s chosen node.</p><p><strong>Notes</strong></p><p>The actions of player 2 are ordered according to the <a href="https://en.wikipedia.org/wiki/Combinatorial_number_system">combinatorial number system</a>, which is different from the order used in the original library in C.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>n::Integer</code> : Number of nodes in the tournament graph.</li><li><code>k::Integer</code> : Size of subsets of nodes in the tournament graph.</li></ul><p><strong>Returns</strong></p><ul><li><code>g::NormalFormGame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory.Generators, Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; g = tournament_game(rng, 5, 2)
5×10 NormalFormGame{2, Float64}

julia&gt; g.players[1]
5×10 Player{2, Float64}:
 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  1.0  1.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0

julia&gt; g.players[2]
10×5 Player{2, Float64}:
 1.0  1.0  0.0  0.0  0.0
 1.0  0.0  1.0  0.0  0.0
 0.0  1.0  1.0  0.0  0.0
 1.0  0.0  0.0  1.0  0.0
 0.0  1.0  0.0  1.0  0.0
 0.0  0.0  1.0  1.0  0.0
 1.0  0.0  0.0  0.0  1.0
 0.0  1.0  0.0  0.0  1.0
 0.0  0.0  1.0  0.0  1.0
 0.0  0.0  0.0  1.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/generators/bimatrix_generators.jl#L369-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GameTheory.Generators.unit_vector_game-Tuple{Random.AbstractRNG, Integer}" href="#GameTheory.Generators.unit_vector_game-Tuple{Random.AbstractRNG, Integer}"><code>GameTheory.Generators.unit_vector_game</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unit_vector_game([rng=GLOBAL_RNG], n; avoid_pure_nash=false)</code></pre><p>Return a NormalFormGame instance of the 2-player game &quot;unit vector game&quot; (Savani and von Stengel, 2016). Payoffs for player 2 are chosen randomly from the [0, 1) range. For player 1, each column contains exactly one 1 payoff and the rest is</p><ol><li></li></ol><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator used.</li><li><code>n::Integer</code> : Number of actions.</li><li><code>avoid_pure_nash::Bool=false</code> : If true, player 1&#39;s payoffs will be placed in order to avoid pure Nash equilibria. (If necessary, the payoffs for player 2 are redrawn so as not to have a dominant action.)</li></ul><p><strong>Returns</strong></p><ul><li><code>g::NormalFormGame</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using GameTheory.Generators, Random

julia&gt; rng = MersenneTwister(123456);

julia&gt; g = unit_vector_game(rng, 5)
5×5 NormalFormGame{2, Float64}

julia&gt; g.players[1]
5×5 Player{2, Float64}:
 0.0  0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0  1.0
 0.0  0.0  0.0  0.0  0.0
 0.0  0.0  1.0  0.0  0.0
 0.0  1.0  0.0  1.0  0.0

julia&gt; g.players[2]
5×5 Player{2, Float64}:
 0.51521   0.574332    0.391494   0.316183  0.913325
 0.74129   0.47338     0.0110828  0.986807  0.302641
 0.582142  0.635053    0.7289     0.324831  0.240347
 0.209969  0.00394602  0.588569   0.627509  0.692993
 0.180649  0.998717    0.0955464  0.974204  0.994846

julia&gt; pure_nash(g)
1-element Vector{Tuple{Int64, Int64}}:
 (2, 5)</code></pre><p>With <code>avoid_pure_nash=true</code>:</p><pre><code class="language-julia hljs">julia&gt; rng = MersenneTwister(123456);

julia&gt; g = unit_vector_game(rng, 5; avoid_pure_nash=true)
5×5 NormalFormGame{2, Float64}

julia&gt; g.players[1]
5×5 Player{2, Float64}:
 0.0  0.0  0.0  0.0  0.0
 1.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  1.0
 0.0  0.0  1.0  0.0  0.0
 0.0  1.0  0.0  1.0  0.0

julia&gt; g.players[2]
5×5 Player{2, Float64}:
 0.51521   0.574332    0.391494   0.316183  0.913325
 0.74129   0.47338     0.0110828  0.986807  0.302641
 0.582142  0.635053    0.7289     0.324831  0.240347
 0.209969  0.00394602  0.588569   0.627509  0.692993
 0.180649  0.998717    0.0955464  0.974204  0.994846

julia&gt; pure_nash(g)
Tuple{Int64, Int64}[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/GameTheory.jl/blob/943de52a60ed1902c734805f1986e4e6e7c6c073/src/generators/bimatrix_generators.jl#L477-L555">source</a></section></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="base_types_and_methods.html">« Base Types and Methods</a><a class="docs-footer-nextpage" href="computing_nash_equilibria.html">Computing Nash Equilibria »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 26 February 2023 13:18">Sunday 26 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
