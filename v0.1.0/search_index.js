var documenterSearchIndex = {"docs":
[{"location":"lib/computing_nash_equilibria.html#computing_nash_equilibria","page":"Computing Nash Equilibria","title":"Computing Nash Equilibria","text":"","category":"section"},{"location":"lib/computing_nash_equilibria.html#Exported","page":"Computing Nash Equilibria","title":"Exported","text":"","category":"section"},{"location":"lib/computing_nash_equilibria.html","page":"Computing Nash Equilibria","title":"Computing Nash Equilibria","text":"Modules = [Games, Games.Generators]\nPages   = [\"pure_nash.jl\", \"support_enumeration.jl\", \"lrsnash.jl\"]\nPrivate = false","category":"page"},{"location":"lib/computing_nash_equilibria.html#Games.pure_nash-Tuple{NormalFormGame}","page":"Computing Nash Equilibria","title":"Games.pure_nash","text":"pure_nash(nfg; ntofind=Inf, tol=1e-8)\n\nFinds all pure action Nash equilibria for a normal form game. It returns an empty array if there is no pure action Nash.\n\nCurrently uses a brute force algorithm, but that hopefully will change in the future.\n\nArguments\n\nnfg::NormalFormGame: Instance of N-player NormalFormGame.\nntofind::Inf: Maximal number of pure action Nash equilibria to be found; default is prod(nfg.nums_actions).\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\nne::Vector{NTuple{N,Int}}: Vector of pure action Nash equilibria.\n\n\n\n\n\n","category":"method"},{"location":"lib/computing_nash_equilibria.html#Games.support_enumeration-Union{Tuple{NormalFormGame{2, T}}, Tuple{T}} where T","page":"Computing Nash Equilibria","title":"Games.support_enumeration","text":"support_enumeration(g)\n\nCompute mixed-action Nash equilibria with equal support size for a 2-player normal form game by support enumeration. For a non-degenerate game input, these are all the Nash equilibria.\n\nThe algorithm checks all the equal-size support pairs; if the players have the same number n of actions, there are 2n choose n minus 1 such pairs. This should thus be used only for small games.\n\nArguments\n\ng::NormalFormGame{2,T}: 2-player NormalFormGame instance.\n\nReturns\n\n::Vector{NTuple{2,Vector{S}}}: Mixed-action Nash equilibria that are found, where S is Float if T is Int or Float, and Rational if T is Rational.\n\n\n\n\n\n","category":"method"},{"location":"lib/computing_nash_equilibria.html#Games.support_enumeration_task-Tuple{Channel, NormalFormGame{2, T} where T<:Real}","page":"Computing Nash Equilibria","title":"Games.support_enumeration_task","text":"support_enumeration_task(c, g)\n\nTask version of support_enumeration.\n\nArguments\n\nc::Channel: Channel to be binded with the support enumeration task.\ng::NormalFormGame{2}: 2-player NormalFormGame instance.\n\nReturns\n\n::Task: Runnable task for generating Nash equilibria.\n\n\n\n\n\n","category":"method"},{"location":"lib/computing_nash_equilibria.html#Games.lrsnash-Tuple{NormalFormGame{2, var\"#s12\"} where var\"#s12\"<:Union{Int64, Rational}}","page":"Computing Nash Equilibria","title":"Games.lrsnash","text":"lrsnash(g)\n\nCompute in exact arithmetic all extreme mixed-action Nash equilibria of a 2-player normal form game with Integer or Rational payoffs. This function calls the Nash equilibrium computation routine in lrslib (through its Julia wrapper LRSLib.jl) which is based on the \"lexicographic reverse search\" vertex enumeration algorithm.\n\nArguments\n\ng::NormalFormGame{2,<:RatOrInt}: 2-player NormalFormGame instance with Integer or Rational payoffs.\n\nReturns\n\n::Vector{NTuple{2,Vector{Rational{BigInt}}}}: Vector of mixed-action Nash equilibria.\n\nExamples\n\nA degenerate game example:\n\njulia> player1 = Player([3 3; 2 5; 0 6]);\n\njulia> player2 = Player([3 2 3; 3 6 1]);\n\njulia> g = NormalFormGame(player1, player2);\n\njulia> lrsnash(g)\n3-element Vector{Tuple{Vector{Rational{BigInt}}, Vector{Rational{BigInt}}}}:\n ([1//1, 0//1, 0//1], [1//1, 0//1])\n ([1//1, 0//1, 0//1], [2//3, 1//3])\n ([0//1, 1//3, 2//3], [1//3, 2//3])\n\nThe set of Nash equilibria of this degenerate game consists of an isolated equilibrium, the third output, and a non-singleton equilibrium component, the extreme points of which are given by the first two outputs.\n\nReferences\n\nD. Avis, G. Rosenberg, R. Savani, and B. von Stengel, \"Enumeration of Nash Equilibria for Two-Player Games,\" Economic Theory (2010), 9-37.\n\n\n\n\n\n","category":"method"},{"location":"lib/computing_nash_equilibria.html#Internal","page":"Computing Nash Equilibria","title":"Internal","text":"","category":"section"},{"location":"lib/computing_nash_equilibria.html","page":"Computing Nash Equilibria","title":"Computing Nash Equilibria","text":"Modules = [Games, Games.Generators]\nPages   = [\"pure_nash.jl\", \"support_enumeration.jl\", \"lrsnash.jl\"]\nPublic = false","category":"page"},{"location":"lib/computing_nash_equilibria.html#Games._indiff_mixed_action!-Union{Tuple{T}, Tuple{Matrix{T}, Vector{T}, Vector{T}, Matrix{T} where T, Vector{Int64}, Vector{Int64}}} where T<:Real","page":"Computing Nash Equilibria","title":"Games._indiff_mixed_action!","text":"_indiff_mixed_action!(A, b, out, payoff_matrix, own_supp, opp_supp)\n\nGiven a player's payoff matrix payoff_matrix, an array own_supp of this player's actions, and an array opp_supp of the opponent's actions, each of length k, compute the opponent's mixed action whose support equals opp_supp and for which the player is indifferent among the actions in own_supp, if any such exists. Return true if such a mixed action exists and actions in own_supp are indeed best responses to it, in which case the outcome is stored in out; false otherwise. Arrays A and b are used in intermediate steps.\n\nArguments\n\nA::Matrix{T}: Matrix of shape (k+1, k+1) used in intermediate steps, where T<:Real.\nb::Vector{T}: Vector of length k+1 used in intermediate steps, where T<:Real.\nout::Vector{T}: Vector of length k to store the nonzero values of the desired mixed action, where T<:Real.\npayoff_matrix::Matrix: The player's payoff matrix, of shape (m, n).\nown_supp::Vector{Int}: Vector containing the player's action indices, of length k.\nopp_supp::Vector{Int}: Vector containing the opponent's action indices, of length k.\n\nReturns\n\n::Bool: true if a desired mixed action exists and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/computing_nash_equilibria.html#Games._support_enumeration_producer-Union{Tuple{T}, Tuple{Channel, Tuple{Matrix{T}, Matrix{T}}}} where T<:Real","page":"Computing Nash Equilibria","title":"Games._support_enumeration_producer","text":"_support_enumeration_producer(c, payoff_matrices)\n\nMain body of support_enumeration_task.\n\nArguments\n\nc::Channel: Channel to be binded with the support enumeration task.\npayoff_matrices::NTuple{2,Matrix{T}}: Payoff matrices of player 1 and player 2, where T<:Real.\n\nPuts\n\nNTuple{2,Vector{S}}: Tuple of Nash equilibrium mixed actions, where S is Float if T is Int or Float, and Rational if T is Rational.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#base_types_and_methods","page":"Base Types and Methods","title":"Base Types and Methods","text":"","category":"section"},{"location":"lib/base_types_and_methods.html#Exported","page":"Base Types and Methods","title":"Exported","text":"","category":"section"},{"location":"lib/base_types_and_methods.html","page":"Base Types and Methods","title":"Base Types and Methods","text":"Modules = [Games, Games.Generators]\nPages   = [\"Games.jl\", \"normal_form_game.jl\"]\nPrivate = false","category":"page"},{"location":"lib/base_types_and_methods.html#Games.Action","page":"Base Types and Methods","title":"Games.Action","text":"Action{T}\n\nAlias for Union{PureAction,MixedAction{T}} where T<:Real.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.ActionProfile","page":"Base Types and Methods","title":"Games.ActionProfile","text":"ActionProfile\n\nAlias for Union{PureActionProfile,MixedActionProfile}.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.MixedAction","page":"Base Types and Methods","title":"Games.MixedAction","text":"MixedAction{T}\n\nAlias for Vector{T} where T<:Real.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.PureAction","page":"Base Types and Methods","title":"Games.PureAction","text":"PureAction\n\nAlias for Integer.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.BROptions","page":"Base Types and Methods","title":"Games.BROptions","text":"BROptions\n\nStruct to contain options for best_response.\n\nFields\n\ntol::Real=1e-8 : Tolerance level.\ntie_breaking::Symbol=:smallest : :smallest or :random.\nrng::AbstractRNG=GLOBAL_RNG : Random number generator.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame{N,T}\n\nType representing an N-player normal form game.\n\nFields\n\nplayers::NTuple{N,Player{N,T<:Real}} : Tuple of Player instances.\nnums_actions::NTuple{N,Int} : Tuple of the numbers of actions, one for each player.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{Array{Player{N, T}, 1}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(players)\n\nConstructor of an N-player NormalFormGame with a vector of N Player instances.\n\nArguments\n\nplayers::Vector{Player} : Vector of Player instances.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{Array{T, M}}, Tuple{M}, Tuple{T}} where {T<:Real, M}","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(payoffs)\n\nConstruct an N-player NormalFormGame for N>=2 with an array payoffs of M=N+1 dimensions, where payoffs[a_1, a_2, ..., a_N, :] contains a profile of N payoff values.\n\nArguments\n\npayoffs::Array{T<:Real} : Array with ndims=N+1 containing payoff profiles.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Real","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(payoffs)\n\nConstruct a symmetric 2-player NormalFormGame with a square matrix.\n\nArguments\n\npayoffs::Matrix{T<:Real} : Square matrix representing each player's payoff matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{N}, Tuple{Type, Tuple{Vararg{Int64, N}}}} where N","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame([T=Float64], nums_actions)\n\nConstructor of an N-player NormalFormGame, consisting of payoffs all 0.\n\nArguments\n\nT::Type : Type of payoff values; defaults to Float64 if not specified.\nnums_actions::NTuple{N,Int} : Numbers of actions of the N players.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, NormalFormGame{N, T} where T<:Real}} where {T<:Real, N}","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(T, g)\n\nConvert g into a new NormalFormGame instance with eltype T.\n\nArguments\n\nT::Type\ng::NormalFormGame\n\nReturns\n\n::NormalFormGame : NormalFormGame instance with eltype T.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{Tuple{Vararg{Player{N, T}, N}}}, Tuple{T}, Tuple{N}} where {N, T}","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(players)\n\nConstructor of an N-player NormalFormGame with a tuple of N Player instances.\n\nArguments\n\nplayers::NTuple{N,Player} : Tuple of Player instances.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.NormalFormGame-Union{Tuple{Vararg{Player{N, T}, N1} where N1}, Tuple{T}, Tuple{N}} where {N, T}","page":"Base Types and Methods","title":"Games.NormalFormGame","text":"NormalFormGame(players...)\n\nConstructor of an N-player NormalFormGame with N Player instances.\n\nArguments\n\nplayers::Player{N,T}... : N Player instances\n\nExamples\n\n# p1, p2, and p3 are all of type `Player{3,T}` for some `T`\nNormalFormGame(p1, p2, p3)\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.Player","page":"Base Types and Methods","title":"Games.Player","text":"Player{N,T}\n\nType representing a player in an N-player normal form game.\n\nFields\n\npayoff_array::Array{T<:Real} : Array representing the player's payoff function.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.Player-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Player{N, T} where T<:Real}} where {T<:Real, N}","page":"Base Types and Methods","title":"Games.Player","text":"Player(T, player)\n\nConvert player into a new Player instance with eltype T.\n\nArguments\n\nT::Type\nplayer::Player\n\nReturns\n\n::Player : Player instance with eltype T.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.best_response-Tuple{Player, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}, BROptions}","page":"Base Types and Methods","title":"Games.best_response","text":"best_response(player, opponents_actions, options)\n\nReturn a best response action to opponents_actions with options as specified by a BROptions instance options.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.best_response-Tuple{Player, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}, Vector{Float64}}","page":"Base Types and Methods","title":"Games.best_response","text":"best_response(player, opponents_actions, payoff_perturbation)\n\nReturn the perturbed best response to opponents_actions.\n\nArguments\n\nplayer::Player : Player instance.\nopponents_actions::Union{Action,ActionProfile,Nothing} : Profile of N-1 opponents' actions. If N=2, then it must be a vector of reals (in which case it is treated as the opponent's mixed action) or a scalar of integer (in which case it is treated as the opponent's pure action). If N>2, then it must be a tuple of N-1 integers (pure actions) or N-1 vectors of reals (mixed actions). (For the degenerate case N=1, it must be nothing.)\npayoff_perturbation::Vector{Float64} : Vector of length equal to the number of actions of the player containing the values (\"noises\") to be added to the payoffs in determining the best response.\n\nReturns\n\n::Int : Best response action.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.best_response-Tuple{Random.AbstractRNG, Player, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}}","page":"Base Types and Methods","title":"Games.best_response","text":"best_response([rng=GLOBAL_RNG], player, opponents_actions;\n              tie_breaking=:smallest, tol=1e-8)\n\nReturn a best response action to opponents_actions.\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG : Random number generator; relevant only with tie_breaking=:random.\nplayer::Player : Player instance.\nopponents_actions::Union{Action,ActionProfile,Nothing} : Profile of N-1 opponents' actions. If N=2, then it must be a vector of reals (in which case it is treated as the opponent's mixed action) or a scalar of integer (in which case it is treated as the opponent's pure action). If N>2, then it must be a tuple of N-1 integers (pure actions) or N-1 vectors of reals (mixed actions). (For the degenerate case N=1, it must be nothing.)\ntie_breaking::Symbol : Control how to break a tie (see Returns for details).\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\n::Int : If tie_breaking=:smallest, returns the best response action with the smallest index; if tie_breaking=:random, returns an action randomly chosen from the best response actions.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.best_responses-Tuple{Player, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}}","page":"Base Types and Methods","title":"Games.best_responses","text":"best_responses(player, opponents_actions; tol=1e-8)\n\nReturn all the best response actions to opponents_actions.\n\nArguments\n\nplayer::Player : Player instance.\nopponents_actions::Union{Action,ActionProfile,Nothing} : Profile of N-1 opponents' actions. If N=2, then it must be a vector of reals (in which case it is treated as the opponent's mixed action) or a scalar of integer (in which case it is treated as the opponent's pure action). If N>2, then it must be a tuple of N-1 integers (pure actions) or N-1 vectors of reals (mixed actions). (For the degenerate case N=1, it must be nothing.)\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\nbest_responses::Vector{Int} : Vector containing all the best response actions.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.delete_action-Union{Tuple{N}, Tuple{NormalFormGame{N, T} where T<:Real, AbstractVector{var\"#s10\"} where var\"#s10\"<:Integer, Integer}} where N","page":"Base Types and Methods","title":"Games.delete_action","text":"delete_action(g, action, player_idx)\n\nReturn a new NormalFormGame instance with the action(s) specified by action deleted from the action set of the player specified by player_idx.\n\nArguments\n\ng::NormalFormGame : NormalFormGame instance.\naction::Union{PureAction, AbstractVector{<:PureAction}} : The action(s) to be deleted.\nplayer_idx::Integer : Index of the player to delete action(s) for.\n\nReturns\n\n::NormalFormGame : NormalFormGame instance with the action(s) deleted as specified.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.delete_action-Union{Tuple{T}, Tuple{N}, Tuple{Player{N, T}, AbstractVector{var\"#s7\"} where var\"#s7\"<:Integer}, Tuple{Player{N, T}, AbstractVector{var\"#s8\"} where var\"#s8\"<:Integer, Integer}} where {N, T}","page":"Base Types and Methods","title":"Games.delete_action","text":"delete_action(player, action[, player_idx=1])\n\nReturn a new Player instance with the action(s) specified by action deleted from the action set of the player specified by player_idx.\n\nArguments\n\nplayer::Player : Player instance.\naction::Union{PureAction,AbstractVector{<:PureAction}}: The action(s) to be deleted.\nplayer_idx::Integer : Index of the player to delete action(s) for.\n\nReturns\n\n::Player : Player instance with the action(s) deleted as specified.\n\nExamples\n\njulia> player = Player([3 0; 0 3; 1 1])\n3×2 Player{2,Int64}:\n 3  0\n 0  3\n 1  1\n\njulia> delete_action(player, 3)\n2×2 Player{2,Int64}:\n 3  0\n 0  3\n\njulia> delete_action(player, 1, 2)\n3×1 Player{2,Int64}:\n 0\n 3\n 1\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.dominated_actions-Union{Tuple{T}, Tuple{Type{T}, Player}} where T<:Real","page":"Base Types and Methods","title":"Games.dominated_actions","text":"dominated_actions(player; tol=1e-8, lp_solver=Games.clp_optimizer_silent)\n\nReturn a vector of actions that are strictly dominated by some mixed actions.\n\nArguments\n\nplayer::Player : Player instance.\ntol::Real : Tolerance level used in determining domination.\nlp_solver::Union{Type{<:MathOptInterface.AbstractOptimizer},Function} : Linear programming solver to be used internally. Pass a MathOptInterface.AbstractOptimizer type (such as Clp.Optimizer) if no option is needed, or a function (such as Games.clp_optimizer_silent) to supply options.\n\nReturns\n\nout::Vector{Int} : Vector of integers representing pure actions, each of which is strictly dominated by some mixed action.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.is_best_response-Tuple{Player, Integer, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}}","page":"Base Types and Methods","title":"Games.is_best_response","text":"is_best_response(player, own_action, opponents_actions; tol=1e-8)\n\nReturn true if own_action is a best response to opponents_actions.\n\nArguments\n\nplayer::Player : Player instance.\nown_action::PureAction : Own pure action (integer).\nopponents_actions::Union{Action,ActionProfile,Nothing} : Profile of N-1 opponents' actions. If N=2, then it must be a vector of reals (in which case it is treated as the opponent's mixed action) or a scalar of integer (in which case it is treated as the opponent's pure action). If N>2, then it must be a tuple of N-1 integers (pure actions) or N-1 vectors of reals (mixed actions). (For the degenerate case N=1, it must be nothing.)\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\n::Bool : True if own_action is a best response to opponents_actions; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.is_best_response-Tuple{Player, Vector{T} where T<:Real, Union{Nothing, Tuple{Vararg{T, N}} where {N, T<:Integer}, Tuple{Vararg{Vector{T}, N}} where {T<:Real, N}, Union{Vector{T}, Integer} where T<:Real}}","page":"Base Types and Methods","title":"Games.is_best_response","text":"is_best_response(player, own_action, opponents_actions; tol=1e-8)\n\nReturn true if own_action is a best response to opponents_actions.\n\nArguments\n\nplayer::Player : Player instance.\nown_action::MixedAction : Own mixed action (vector of reals).\nopponents_actions::Union{Action,ActionProfile,Nothing} : Profile of N-1 opponents' actions. If N=2, then it must be a vector of reals (in which case it is treated as the opponent's mixed action) or a scalar of integer (in which case it is treated as the opponent's pure action). If N>2, then it must be a tuple of N-1 integers (pure actions) or N-1 vectors of reals (mixed actions). (For the degenerate case N=1, it must be nothing.)\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\n::Bool : True if own_action is a best response to opponents_actions; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.is_dominated-Union{Tuple{T}, Tuple{Type{T}, Player, Integer}} where T<:Real","page":"Base Types and Methods","title":"Games.is_dominated","text":"is_dominated(player, action; tol=1e-8, lp_solver=Games.clp_optimizer_silent)\n\nDetermine whether action is strictly dominated by some mixed action.\n\nArguments\n\nplayer::Player : Player instance.\naction::PureAction : Integer representing a pure action.\ntol::Real : Tolerance level used in determining domination.\nlp_solver : Linear programming solver to be used internally. Pass a MathOptInterface.AbstractOptimizer type (such as Clp.Optimizer) if no option is needed, or a function (such as Games.clp_optimizer_silent) to supply options.\n\nReturns\n\n::Bool : True if action is strictly dominated by some mixed action; false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.is_nash","page":"Base Types and Methods","title":"Games.is_nash","text":"is_nash(g, action_profile; tol=1e-8)\n\nReturn true if action_profile is a Nash equilibrium.\n\nArguments\n\ng::NormalFormGame : Instance of N-player NormalFormGame.\naction_profile::ActionProfile : Tuple of N integers (pure actions) or N vectors of reals (mixed actions).\ntol::Real : Tolerance to be used to determine best response actions.\n\nReturns\n\n::Bool\n\n\n\n\n\n","category":"function"},{"location":"lib/base_types_and_methods.html#Games.is_nash-Tuple{NormalFormGame{1, T} where T<:Real, Union{Vector{T}, Integer} where T<:Real}","page":"Base Types and Methods","title":"Games.is_nash","text":"is_nash(g, action; tol=1e-8)\n\nReturn true if action is a Nash equilibrium of a trivial game with 1 player.\n\nArguments\n\ng::NormalFormGame{1} : Instance of 1-player NormalFormGame.\naction::Action : Integer (pure action) or vector of reals (mixed action).\ntol::Float64 : Tolerance to be used to determine best response actions.\n\nReturns\n\n::Bool\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.is_pareto_dominant","page":"Base Types and Methods","title":"Games.is_pareto_dominant","text":"is_pareto_dominant(g, action_profile)\n\nReturn true if action_profile is Pareto dominant for game g.\n\nArguments\n\ng::NormalFormGame : Instance of N-player NormalFormGame.\naction_profile::PureActionProfile : Tuple of N integers (pure actions).\n\nReturns\n\n::Bool\n\n\n\n\n\n","category":"function"},{"location":"lib/base_types_and_methods.html#Games.is_pareto_efficient","page":"Base Types and Methods","title":"Games.is_pareto_efficient","text":"is_pareto_efficient(g, action_profile)\n\nReturn true if action_profile is Pareto efficient for game g.\n\nArguments\n\ng::NormalFormGame : Instance of N-player NormalFormGame.\naction_profile::PureActionProfile : Tuple of N integers (pure actions).\n\nReturns\n\n::Bool\n\n\n\n\n\n","category":"function"},{"location":"lib/base_types_and_methods.html#Games.payoff_vector-Tuple{Player, Tuple{Vararg{T, N}} where {N, T<:Integer}}","page":"Base Types and Methods","title":"Games.payoff_vector","text":"payoff_vector(player, opponents_actions)\n\nReturn a vector of payoff values for a Player in an N>2 player game, one for each own action, given a tuple of the opponents' pure actions.\n\nArguments\n\nplayer::Player : Player instance.\nopponents_actions::PureActionProfile : Tuple of N-1 opponents' pure actions.\n\nReturns\n\n::Vector : Payoff vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.payoff_vector-Tuple{Player{1, T} where T<:Real, Nothing}","page":"Base Types and Methods","title":"Games.payoff_vector","text":"payoff_vector(player, opponent_action)\n\nReturn a vector of payoff values for a Player in a trivial game with 1 player, one for each own action.\n\nArguments\n\nplayer::Player{1} : Player instance.\nopponent_action::Nothing\n\nReturns\n\n::Vector : Payoff vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.payoff_vector-Tuple{Player{2, T} where T<:Real, Integer}","page":"Base Types and Methods","title":"Games.payoff_vector","text":"payoff_vector(player, opponent_action)\n\nReturn a vector of payoff values for a Player in a 2-player game, one for each own action, given the opponent's pure action.\n\nArguments\n\nplayer::Player{2} : Player instance.\nopponent_action::PureAction : Opponent's pure action (integer).\n\nReturns\n\n::Vector : Payoff vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.payoff_vector-Tuple{Player{2, T} where T<:Real, Vector{T} where T<:Real}","page":"Base Types and Methods","title":"Games.payoff_vector","text":"payoff_vector(player, opponent_action)\n\nReturn a vector of payoff values for a Player in a 2-player game, one for each own action, given the opponent's mixed action.\n\nArguments\n\nplayer::Player{2} : Player instance.\nopponent_action::MixedAction : Opponent's mixed action (vector of reals).\n\nReturns\n\n::Vector : Payoff vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.payoff_vector-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Player{N, T1}, Tuple{Vararg{Vector{T2}, N}} where N}} where {N, T1, T2}","page":"Base Types and Methods","title":"Games.payoff_vector","text":"payoff_vector(player, opponents_actions)\n\nReturn a vector of payoff values for a Player in an N>2 player game, one for each own action, given a tuple of the opponents' mixed actions.\n\nArguments\n\nplayer::Player : Player instance.\nopponents_actions::MixedActionProfile : Tuple of N-1 opponents' mixed actions.\n\nReturns\n\n::Vector : Payoff vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Games.pure2mixed-Tuple{Integer, Integer}","page":"Base Types and Methods","title":"Games.pure2mixed","text":"pure2mixed(num_actions, action)\n\nConvert a pure action to the corresponding mixed action.\n\nArguments\n\nnum_actions::Integer : The number of the pure actions (= the length of a mixed action).\naction::PureAction : The pure action to convert to the corresponding mixed action.\n\nReturns\n\nmixed_action::Vector{Float64} : The mixed action representation of the given pure action.\n\n\n\n\n\n","category":"method"},{"location":"lib/base_types_and_methods.html#Internal","page":"Base Types and Methods","title":"Internal","text":"","category":"section"},{"location":"lib/base_types_and_methods.html","page":"Base Types and Methods","title":"Base Types and Methods","text":"Modules = [Games, Games.Generators]\nPages   = [\"Games.jl\", \"normal_form_game.jl\"]\nPublic = false","category":"page"},{"location":"lib/base_types_and_methods.html#Games.MixedActionProfile","page":"Base Types and Methods","title":"Games.MixedActionProfile","text":"MixedActionProfile{T,N}\n\nAlias for NTuple{N,MixedAction{T}} where T<:Real.\n\n\n\n\n\n","category":"type"},{"location":"lib/base_types_and_methods.html#Games.PureActionProfile","page":"Base Types and Methods","title":"Games.PureActionProfile","text":"PureActionProfile{N,T}\n\nAlias for NTuple{N,T} where T<:PureAction.\n\n\n\n\n\n","category":"type"},{"location":"lib/index.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"lib/index.html","page":"Index","title":"Index","text":"Modules = [Games, Games.Generators]","category":"page"},{"location":"lib/util.html#util","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"lib/util.html","page":"Utilities","title":"Utilities","text":"This is documentation for util.jl.","category":"page"},{"location":"lib/util.html#Exported","page":"Utilities","title":"Exported","text":"","category":"section"},{"location":"lib/util.html","page":"Utilities","title":"Utilities","text":"Modules = [Games, Games.Generators]\nPages   = [\"util.jl\"]\nPrivate = false","category":"page"},{"location":"lib/util.html#Internal","page":"Utilities","title":"Internal","text":"","category":"section"},{"location":"lib/util.html","page":"Utilities","title":"Utilities","text":"Modules = [Games, Games.Generators]\nPages   = [\"util.jl\"]\nPublic = false","category":"page"},{"location":"lib/util.html#Games.clp_optimizer_silent-Tuple{}","page":"Utilities","title":"Games.clp_optimizer_silent","text":"clp_optimizer_silent()\n\nFunction that returns a Clp.Optimizer instance with LogLevel set to 0.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Games.jl","page":"Home","title":"Games.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Games.jl is a Julia package about algorithms and data structures for Game Theory.","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Games.jl is an unregistered package that is currently under development.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"To install the package, enter the Pkg mode by pressing ] and run","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"add https://github.com/QuantEcon/Games.jl","category":"page"},{"location":"index.html#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Once installed, the Games package can be used by typing","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Games","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The Base type Player can be created by passing a payoff matrix.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"player1 = Player([3 1; 0 2])","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A 2-player NormalFormGame can be created either by passing Player instances,","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"player2 = Player([2 0; 1 3])\ng = NormalFormGame((player1, player2))","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"or by passing a payoff matrix directly.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"payoff_bimatrix = Array{Int}(undef, 2, 2, 2)\npayoff_bimatrix[1, 1, :] = [3, 2]\npayoff_bimatrix[1, 2, :] = [1, 1]\npayoff_bimatrix[2, 1, :] = [0, 0]\npayoff_bimatrix[2, 2, :] = [2, 3]\ng = NormalFormGame(payoff_bimatrix)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"After constructing a NormalFormGame, we can find its Nash Equilibria by using methods of Games. For example, pure_nash finds all pure action Nash Equilibria by enumeration.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pure_nash(g)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Please see the notebooks on QuantEcon for more details.","category":"page"},{"location":"index.html#notebooks","page":"Home","title":"Notebooks","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Some notebooks for demonstration are available:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Tools for Game Theory\nA Recursive Formulation of Repeated Games","category":"page"},{"location":"index.html#Library-Outline","page":"Home","title":"Library Outline","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Base Types and Methods\nGame Generators\nComputing Nash Equilibria\nRepeated Games\nUtilities","category":"page"},{"location":"lib/repeated_games.html#repeated_games","page":"Repeated Games","title":"Repeated Games","text":"","category":"section"},{"location":"lib/repeated_games.html#Exported","page":"Repeated Games","title":"Exported","text":"","category":"section"},{"location":"lib/repeated_games.html","page":"Repeated Games","title":"Repeated Games","text":"Modules = [Games, Games.Generators]\nPages   = [\"repeated_game_util.jl\", \"repeated_game.jl\"]\nPrivate = false","category":"page"},{"location":"lib/repeated_games.html#Games.RepeatedGame","page":"Repeated Games","title":"Games.RepeatedGame","text":"RepeatedGame{N,T}\n\nType representing an N-player repeated game.\n\nFields\n\nsg::NormalFormGame{N, T} : The stage game used to create the repeated game.\ndelta::Float64 : The common discount rate at which all players discount the future.\n\n\n\n\n\n","category":"type"},{"location":"lib/repeated_games.html#Games.RepeatedGame-Tuple{Player, Player, Float64}","page":"Repeated Games","title":"Games.RepeatedGame","text":"RepeatedGame(p1, p2, delta)\n\nHelper constructor that builds a repeated game for two players.\n\nArguments\n\np1::Player : The first player.\np2::Player : The second player.\ndelta::Float64 : The common discount rate at which all players discount the future.\n\nReturns\n\n::RepeatedGame : The repeated game.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.outerapproximation-Tuple{RepeatedGame{2, T} where T<:Real}","page":"Repeated Games","title":"Games.outerapproximation","text":"outerapproximation(rpd; nH=32, tol=1e-8, maxiter=500, check_pure_nash=true,\n                   verbose=false, nskipprint=50,\n                   plib=default_library(2, Float64),\n                   lp_solver=Games.clp_optimizer_silent)\n\nApproximates the set of equilibrium values for a repeated game with the outer hyperplane approximation described by Judd, Yeltekin, Conklin (2002).\n\nArguments\n\nrpd::RepGame2 : Two player repeated game.\nnH::Int : Number of subgradients used for the approximation.\ntol::Float64 : Tolerance in differences of set.\nmaxiter::Int : Maximum number of iterations.\ncheck_pure_nash: Whether to perform a check about whether a pure Nash equilibrium exists.\nverbose::Bool : Whether to display updates about iterations and distance.\nnskipprint::Int : Number of iterations between printing information (assuming verbose=true).\nplib::Polyhedra.Library: Allows users to choose a particular package for the geometry computations. (See Polyhedra.jl docs for more info). By default, it chooses to use Polyhedra.DefaultLibrary.\nlp_solver : Linear programming solver to be used internally. Pass a MathOptInterface.AbstractOptimizer type (such as Clp.Optimizer) if no option is needed, or a function (such as Games.clp_optimizer_silent) to supply options.\n\nReturns\n\nvertices::Matrix{Float64} : Vertices of the outer approximation of the value set.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.unpack-Tuple{RepeatedGame}","page":"Repeated Games","title":"Games.unpack","text":"unpack(rpd)\n\nHelper function that unpacks the elements of a repeated game.\n\nArguments\n\nrpd::RepeatedGame : The repeated game.\n\nReturns\n\n::Tuple{NormalFormGame, Float64} : A tuple containing the stage game and the delta.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.worst_value_1","page":"Repeated Games","title":"Games.worst_value_1","text":"See worst_value_i for documentation\n\n\n\n\n\n","category":"function"},{"location":"lib/repeated_games.html#Games.worst_value_2","page":"Repeated Games","title":"Games.worst_value_2","text":"See worst_value_i for documentation\n\n\n\n\n\n","category":"function"},{"location":"lib/repeated_games.html#Games.worst_value_i","page":"Repeated Games","title":"Games.worst_value_i","text":"worst_value_i(rpd, H, C, i)\n\nGiven a constraint w ∈ W, this finds the worst possible payoff for agent i.\n\nArguments\n\nrpd::RepGame2 : Two player repeated game.\nH::Matrix{Float64} : Matrix of shape (nH, 2) containing the subgradients here nH is the number of subgradients.\nC::Vector{Float64} : The array containing the hyperplane levels.\ni::Int : The player of interest.\nlp_solver : Linear programming solver to be used internally. Pass a MathOptInterface.AbstractOptimizer type (such as Clp.Optimizer) if no option is needed, or a function (such as Games.clp_optimizer_silent) to supply options.\n\nReturns\n\nout::Float64 : Worst possible payoff for player i.\n\n\n\n\n\n","category":"function"},{"location":"lib/repeated_games.html#Internal","page":"Repeated Games","title":"Internal","text":"","category":"section"},{"location":"lib/repeated_games.html","page":"Repeated Games","title":"Repeated Games","text":"Modules = [Games, Games.Generators]\nPages   = [\"repeated_game_util.jl\", \"repeated_game.jl\"]\nPublic = false","category":"page"},{"location":"lib/repeated_games.html#Games.RepGame2","page":"Repeated Games","title":"Games.RepGame2","text":"RepGame2\n\nType representing a 2-player repeated game; alias for RepeatedGame{2}.\n\n\n\n\n\n","category":"type"},{"location":"lib/repeated_games.html#Games.initialize_LP_matrices-Tuple{RepeatedGame{2, T} where T<:Real, Matrix{Float64}}","page":"Repeated Games","title":"Games.initialize_LP_matrices","text":"initialize_LP_matrices(rpd, H)\n\nInitialize matrices for the linear programming problems.\n\nArguments\n\nrpd::RepeatedGame : Two player repeated game.\nH::Matrix{Float64} : Matrix of shape (nH, 2) containing the subgradients used to approximate the value set, where nH is the number of subgradients.\n\nReturns\n\nc::Vector{Float64} : Vector of length nH used to determine which subgradient should be used, where nH is the number of subgradients.\nA::Matrix{Float64} : Matrix of shape (nH+2, 2) with nH set constraints and to be filled with 2 additional incentive compatibility constraints.\nb::Vector{Float64} : Vector of length nH+2 to be filled with the values for the constraints.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.initialize_sg_hpl-Tuple{Int64, Vector{Float64}, Float64}","page":"Repeated Games","title":"Games.initialize_sg_hpl","text":"initialize_sg_hpl(nH, o, r)\n\nInitializes subgradients, extreme points and hyperplane levels for the approximation of the convex value set of a 2 player repeated game.\n\nArguments\n\nnH::Int : Number of subgradients used for the approximation.\no::Vector{Float64} : Origin for the approximation.\nr::Float64 : Radius for the approximation.\n\nReturns\n\nC::Vector{Float64} : Vector of length nH containing the hyperplane levels.\nH::Matrix{Float64} : Matrix of shape (nH, 2) containing the subgradients.\nZ::Matrix{Float64} : Matrix of shape (nH, 2) containing the extreme points of the value set.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.initialize_sg_hpl-Tuple{RepeatedGame, Int64}","page":"Repeated Games","title":"Games.initialize_sg_hpl","text":"initialize_sg_hpl(rpd, nH)\n\nInitializes subgradients, extreme points and hyperplane levels for the approximation of the convex value set of a 2 player repeated game by choosing an appropriate origin and radius.\n\nArguments\n\nrpd::RepeatedGame : Two player repeated game.\nnH::Int : Number of subgradients used for the approximation.\n\nReturns\n\nC::Vector{Float64} : Vector of length nH containing the hyperplane levels.\nH::Matrix{Float64} : Matrix of shape (nH, 2) containing the subgradients.\nZ::Matrix{Float64} : Matrix of shape (nH, 2) containing the extreme points of the value set.\n\n\n\n\n\n","category":"method"},{"location":"lib/repeated_games.html#Games.unitcircle-Tuple{Int64}","page":"Repeated Games","title":"Games.unitcircle","text":"unitcircle(npts)\n\nPlaces npts equally spaced points along the 2 dimensional unit circle and returns the points with x coordinates in first column and y coordinates in second column.\n\nArguments\n\nnpts::Int : Number of points to be placed.\n\nReturns\n\npts::Matrix{Float64} : Matrix of shape (nH, 2) containing the coordinates of the points.\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#game_generators","page":"Game Generators","title":"Game Generators","text":"","category":"section"},{"location":"lib/game_generators.html#Exported","page":"Game Generators","title":"Exported","text":"","category":"section"},{"location":"lib/game_generators.html","page":"Game Generators","title":"Game Generators","text":"Modules = [Games, Games.Generators]\nPages   = [\"random.jl\", \"generators/bimatrix_generators.jl\"]\nPrivate = false","category":"page"},{"location":"lib/game_generators.html#Games.covariance_game-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}, Real}} where N","page":"Game Generators","title":"Games.covariance_game","text":"covariance_game([rng=GLOBAL_RNG], nums_actions, rho)\n\nReturn a random N-player NormalFormGame instance with N>=2 where the payoff profiles are drawn independently from the standard multi-normal with the covariance of any pair of payoffs equal to rho, as studied in Rinott and Scarsini (2000).\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nnums_actions::NTuple{N,Int}: Tuple of the numbers of actions, one for each player.\nrho::Real: Covariance of a pair of payoff values. Must be in [-1/(N-1), 1], where N is the number of players.\n\nReturns\n\n::NormalFormGame: The generated random N-player NormalFormGame.\n\nReferences\n\nY. Rinott and M. Scarsini, \"On the Number of Pure Strategy Nash Equilibria in Random Games,\" Games and Economic Behavior (2000), 274-293.\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.random_game-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N","page":"Game Generators","title":"Games.random_game","text":"random_game([rng=GLOBAL_RNG], nums_actions)\n\nReturn a random N-player NormalFormGame instance where the payoffs are drawn independently from the uniform distribution on [0, 1).\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nnums_actions::NTuple{N,Int}: Tuple of the numbers of actions, one for each player.\n\nReturns\n\n::NormalFormGame: The generated random N-player NormalFormGame.\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.random_mixed_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N","page":"Game Generators","title":"Games.random_mixed_actions","text":"random_mixed_actions([rng=GLOBAL_RNG], nums_actions)\n\nReturn a tuple of random mixed actions (vectors of floats).\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nnums_actions::NTuple{N,Int}: N-tuple of the numbers of actions, one for each player.\n\nReturns\n\n::NTuple{N,Vector{Float64}}: N-tuple of random mixed actions.\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.random_pure_actions-Union{Tuple{N}, Tuple{Random.AbstractRNG, Tuple{Vararg{Int64, N}}}} where N","page":"Game Generators","title":"Games.random_pure_actions","text":"random_pure_actions([rng=GLOBAL_RNG], nums_actions)\n\nReturn a tuple of random pure actions (integers).\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nnums_actions::NTuple{N,Int}: N-tuple of the numbers of actions, one for each player.\n\nReturns\n\n::NTuple{N,Int}: N-tuple of random pure actions.\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.Generators.blotto_game","page":"Game Generators","title":"Games.Generators.blotto_game","text":"blotto_game([rng=GLOBAL_RNG], h, t, rho[, mu=0])\n\nReturn a NormalFormGame instance of a 2-player non-zero sum Colonel Blotto game (Hortala-Vallve and Llorente-Saguer, 2012), where the players have an equal number t of troops to assign to h hills (so that the number of actions for each player is equal to (t+h-1) choose (h-1) = (T+h-1)!/(T!*(h-1)!)). Each player has a value for each hill that he receives if he assigns strictly more troops to the hill than his opponent (ties are broken uniformly at random), where the values are drawn from a multivariate normal distribution with covariance rho. Each player’s payoff is the sum of the values of the hills won by that player.\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nh::Integer : Number of hills.\nt::Integer : Number of troops.\nrho::Real : Covariance of the players' values of each hill. Must be in [-1, 1].\nmu::Real=0 : Mean of the players' values of each hill.\n\nReturns\n\ng::NormalFormGame\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> g = blotto_game(rng, 2, 3, 0.5)\n4×4 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n4×4 Player{2,Float64}:\n 0.186434  -0.494479  -0.494479  -0.494479\n 0.867347   0.186434  -0.494479  -0.494479\n 0.867347   0.867347   0.186434  -0.494479\n 0.867347   0.867347   0.867347   0.186434\n\njulia> g.players[2]\n4×4 Player{2,Float64}:\n -0.688223  -1.02919   -1.02919   -1.02919\n -0.347259  -0.688223  -1.02919   -1.02919\n -0.347259  -0.347259  -0.688223  -1.02919\n -0.347259  -0.347259  -0.347259  -0.688223\n\n\n\n\n\n","category":"function"},{"location":"lib/game_generators.html#Games.Generators.ranking_game","page":"Game Generators","title":"Games.Generators.ranking_game","text":"ranking_game([rng=GLOBAL_RNG], n[, steps=10])\n\nReturn a NormalFormGame instance of (the 2-player version of) the \"ranking game\" studied by Goldberg et al. (2013), where each player chooses an effort level associated with a score and a cost which are both increasing functions with randomly generated step sizes. The player with the higher score wins the first prize, whose value is 1, and the other player obtains the \"second prize\" of value 0; in the case of a tie, the first prize is split and each player receives a value of 0.5. The payoff of a player is given by the value of the prize minus the cost of the effort.\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nn::Integer : Number of actions, i.e, number of possible effort levels.\nsteps::Integer=10 : Parameter determining the upper bound for the size of the random steps for the scores and costs for each player: The step sizes for the scores are drawn from 1, ..., steps, while those for the costs are multiples of 1/(n*steps), where the cost of effort level 1 is 0, and the maximum possible cost of effort level n is less than or equal to 1.\n\nReturns\n\ng::NormalFormGame\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> g = ranking_game(rng, 5)\n5×5 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n5×5 Player{2,Float64}:\n 0.5    0.0    0.0    0.0    0.0\n 0.84  -0.16  -0.16  -0.16  -0.16\n 0.8    0.8   -0.2   -0.2   -0.2\n 0.78   0.78   0.78  -0.22  -0.22\n 0.6    0.6    0.6    0.6   -0.4\n\njulia> g.players[2]\n5×5 Player{2,Float64}:\n 0.5   0.0    0.0    0.0    0.0\n 0.84  0.84  -0.16  -0.16  -0.16\n 0.7   0.7    0.7   -0.3   -0.3\n 0.5   0.5    0.5    0.5   -0.5\n 0.36  0.36   0.36   0.36   0.36\n\n\n\n\n\n","category":"function"},{"location":"lib/game_generators.html#Games.Generators.sgc_game-Tuple{Integer}","page":"Game Generators","title":"Games.Generators.sgc_game","text":"sgc_game(k)\n\nReturn a NormalFormGame instance of the 2-player game introduced by Sandholm, Gilpin, and Conitzer (2005), which has a unique Nash equilibrium, where each player plays half of the actions with positive probabilities. Payoffs are normalized so that the minimum and the maximum payoffs are 0 and 1, respectively.\n\nArguments\n\nk::Integer : Positive integer determining the number of actions. The returned game will have 4*k-1 actions for each player.\n\nReturns\n\ng::NormalFormGame\n\nExamples\n\njulia> g = sgc_game(2)\n7×7 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n7×7 Player{2,Float64}:\n 0.75  0.5   1.0   0.5   0.5   0.5   0.5\n 1.0   0.75  0.5   0.5   0.5   0.5   0.5\n 0.5   1.0   0.75  0.5   0.5   0.5   0.5\n 0.0   0.0   0.0   0.75  0.0   0.0   0.0\n 0.0   0.0   0.0   0.0   0.75  0.0   0.0\n 0.0   0.0   0.0   0.0   0.0   0.75  0.0\n 0.0   0.0   0.0   0.0   0.0   0.0   0.75\n\njulia> g.players[2]\n7×7 Player{2,Float64}:\n 0.75  0.5   1.0   0.5   0.5   0.5   0.5\n 1.0   0.75  0.5   0.5   0.5   0.5   0.5\n 0.5   1.0   0.75  0.5   0.5   0.5   0.5\n 0.0   0.0   0.0   0.0   0.75  0.0   0.0\n 0.0   0.0   0.0   0.75  0.0   0.0   0.0\n 0.0   0.0   0.0   0.0   0.0   0.0   0.75\n 0.0   0.0   0.0   0.0   0.0   0.75  0.0\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.Generators.tournament_game-Tuple{Integer, Integer}","page":"Game Generators","title":"Games.Generators.tournament_game","text":"tournament_game(n, k; seed=-1)\n\nReturn a NormalFormGame instance of the 2-player win-lose game, whose payoffs are either 0 or 1, introduced by Anbalagan et al. (2013). Player 1 has n actions, which constitute the set of nodes {1, ..., n}, while player 2 has n choose k actions, each corresponding to a subset of k elements of the set of n nodes. Given a randomly generated tournament graph on the n nodes, the payoff for player 1 is 1 if, in the tournament, the node chosen by player 1 dominates all the nodes in the k-subset chosen by player 2. The payoff for player 2 is 1 if player 2's k-subset contains player 1's chosen node.\n\nNotes\n\nThe actions of player 2 are ordered according to the combinatorial number system, which is different from the order used in the original library in C.\n\nArguments\n\nn::Integer : Number of nodes in the tournament graph.\nk::Integer : Size of subsets of nodes in the tournament graph.\nseed::Integer=-1: Seed for random number generator. If seed is negative, then GLOBAL_RNG is used.\n\nReturns\n\ng::NormalFormGame\n\nExamples\n\njulia> seed = 1234;\n\njulia> g = tournament_game(5, 2; seed=seed)\n5×10 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n5×10 Player{2,Float64}:\n 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  1.0  1.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> g.players[2]\n10×5 Player{2,Float64}:\n 1.0  1.0  0.0  0.0  0.0\n 1.0  0.0  1.0  0.0  0.0\n 0.0  1.0  1.0  0.0  0.0\n 1.0  0.0  0.0  1.0  0.0\n 0.0  1.0  0.0  1.0  0.0\n 0.0  0.0  1.0  1.0  0.0\n 1.0  0.0  0.0  0.0  1.0\n 0.0  1.0  0.0  0.0  1.0\n 0.0  0.0  1.0  0.0  1.0\n 0.0  0.0  0.0  1.0  1.0\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Games.Generators.unit_vector_game-Tuple{Random.AbstractRNG, Integer}","page":"Game Generators","title":"Games.Generators.unit_vector_game","text":"unit_vector_game([rng=GLOBAL_RNG], n; avoid_pure_nash=false)\n\nReturn a NormalFormGame instance of the 2-player game \"unit vector game\" (Savani and von Stengel, 2016). Payoffs for player 2 are chosen randomly from the [0, 1) range. For player 1, each column contains exactly one 1 payoff and the rest is\n\n\n\nArguments\n\nrng::AbstractRNG=GLOBAL_RNG: Random number generator used.\nn::Integer : Number of actions.\navoid_pure_nash::Bool=false : If true, player 1's payoffs will be placed in order to avoid pure Nash equilibria. (If necessary, the payoffs for player 2 are redrawn so as not to have a dominant action.)\n\nReturns\n\ng::NormalFormGame\n\nExamples\n\njulia> rng = MersenneTwister(1234);\n\njulia> g = unit_vector_game(rng, 5)\n5×5 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n5×5 Player{2,Float64}:\n 0.0  0.0  0.0  0.0  0.0\n 1.0  1.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  1.0  1.0  0.0\n\njulia> g.players[2]\n5×5 Player{2,Float64}:\n 0.590845  0.854147  0.648882   0.112486   0.950498\n 0.766797  0.200586  0.0109059  0.276021   0.96467\n 0.566237  0.298614  0.066423   0.651664   0.945775\n 0.460085  0.246837  0.956753   0.0566425  0.789904\n 0.794026  0.579672  0.646691   0.842714   0.82116\n\njulia> pure_nash(g)\n1-element Array{Tuple{Int64,Int64},1}:\n (2, 1)\n\nWith avoid_pure_nash=true:\n\njulia> rng = MersenneTwister(1234);\n\njulia> g = unit_vector_game(rng, 5; avoid_pure_nash=true)\n5×5 NormalFormGame{2,Float64}\n\njulia> g.players[1]\n5×5 Player{2,Float64}:\n 0.0  0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  1.0  1.0  0.0  1.0\n 0.0  0.0  0.0  0.0  0.0\n 1.0  0.0  0.0  0.0  0.0\n\njulia> g.players[2]\n5×5 Player{2,Float64}:\n 0.590845  0.854147  0.648882   0.112486   0.950498\n 0.766797  0.200586  0.0109059  0.276021   0.96467\n 0.566237  0.298614  0.066423   0.651664   0.945775\n 0.460085  0.246837  0.956753   0.0566425  0.789904\n 0.794026  0.579672  0.646691   0.842714   0.82116\n\njulia> pure_nash(g)\n0-element Array{Tuple{Int64,Int64},1}\n\n\n\n\n\n","category":"method"},{"location":"lib/game_generators.html#Internal","page":"Game Generators","title":"Internal","text":"","category":"section"},{"location":"lib/game_generators.html","page":"Game Generators","title":"Game Generators","text":"Modules = [Games, Games.Generators]\nPages   = [\"random.jl\", \"generators/bimatrix_generators.jl\"]\nPublic = false","category":"page"}]
}
